-------------------------------------------------------------------------------------
--                                                                          
--                     Generated by ModelSim SE 6.2b                
--                                                                                                      
--                                                                          
-------------------------------------------------------------------------------------
--                                                                          
-- "gen_vectorial.vhd" design file
--                                                                     
-------------------------------------------------------------------------------------
--                 
-- Environment Definition   
-- 
-- "gen_vectorial.mpf"


-------------------------------------------------------------------------------------

-- CREATION DATE        : 18-Jun-2007           
-- AUTOR                : DIEGO P               


--------------------------------------------------------------------------------
-- GENERADOR VECTORIAL DE VECTORES DE TEST, EN FOMATO SERIE O BUS
--------------------------------------------------------------------------------

--  DEFINITION       
--------------------------------------------------------------------------------
--
--  La eleccion del ancho de bus es configurable como parametro generico
--      WIDTH     = 1 para formato serie
--      WIDTH max = 16 (formato bus)
--
--  Se considera valor por defecto el especificado como parametro generico 
--      DEFAULT_VALUE : STD_LOGIC;     (en formato bus se aplica a todos los bits)
--
--
-- DESCRIPTION
--------------------------------------------------------------------------------

--  VALOR A REPRESENTAR (INPUT):
--
--      en los indices impares tenemos el valor a generar (salida en "vector"), y en los pares el
--      numero de ciclos que ese valor debe permanecer activo:
--                  
--                127     126       125      124                         1        0
--             -----------------------------------------------------------------------
--            |  value | cycles |  value | cycles |   ...  |   ...  |    ?   |    0   | 
--             -----------------------------------------------------------------------               
--
--      p.e. valores : vector_integer := (-1,2,2,4, OTHERS=>0);
--
--      El final del vector se indica con un cero en el numero de ciclos.
--      Los valores de entrada =-1 son considerados alta impedancia en el vector de test generado
--
--
-- LIMITACIONES:
--
--      el numero maximo de valores a generar ('values') es 63 (= 128/2 -1)
--      el valor maximo a representar ('value') es d'65535 (formato serie o paralelo) 
--      el numero maximo de ciclos de reloj ('cycles') por cada bit(serie) o valor(bus) es 65535 (2048us a 32Mhz)
--
--      En el formato serie el numero de ciclos indica el numero de ciclos por cada bit, por lo que todos los
--      bits tienen el mismo numero de ciclos
-- 
-- ERROR DE FORMATO:
--
--      No se debe especificar un valor menor a -1 para representar 'Z'. 
--      No se debe especificar un numero de ciclos negativo (error).
--      El final del vector se indica con un cero en el numero de ciclos (el valor corrrespondiente es ignorado).
--      
--      Si se produce un error de formato en los valores introducidos, se produce un error (salida "error"=1) 
--      que deshabilita la generation del vector, y su salida será el valor por defecto especificado (DEFAULT_VALUE)
--
-- RETARDOS:
--
--      Desde que se aplica el trigger hasta que comienza la generacion del vector transcurre 1 ciclo (+ procesamiento)
--
-- ABORTADO:
--
--      Para abortar la generacion entre triggers aplicar un areset (la salida será el valor por defecto).

-- EJEMPLOS:
--
--(a)   WIDTH = 1 (serial), DEFAULT_VALUE = 'Z':    
--
--      (-1, 2, 9, 2, 0, 10, OTHERS => 0)   
-- 
--      1- 'Z'                      for  2*t_clk_period 
--      2- '1''0''0''1'             for  4*(2 cycles/bit) 
--      3- '0'                      for 10*t_clk_period 
--      4- 'Z' (default_value)      upto next trigger 
--
--               _
-- trigg  ______| |____________________________________________________________________________________________________
--
--                1     2____              ____3                      4                                           
--        --------------|    |____________|    |______________________-------------------------------------------------               
--                                                                     _
-- fin    ____________________________________________________________| |______________________________________________

--
--(b)   WIDTH > 1 (bus or parallel), DEFAULT_VALUE = '0':   
--
--
--      (-1, 13, 9, 33, OTHERS => 0)       
--  
--      1- "Z......Z"                   for 13*t_clk_period
--      2- "0..01001"                   for 33*t_clk_period
--      3- "0......0" (default_value)   upto next trigger
--
--      >> min bus width = 4
--   
--               _
-- trigg  ______| |____________________________________________________________________________________________________
--
--        ________1______________________2____________________________________________________3________________________
--        __0000__X_________ZZZZ_________X________________________1001________________________X__________0000__________
--
--                                                                                             _
-- fin    ____________________________________________________________________________________| |______________________
--




LIBRARY ieee; 
USE ieee.std_logic_1164.all; 
USE ieee.std_logic_arith.all;
USE ieee.std_logic_signed.all;

LIBRARY ieee; 
USE ieee.math_real.all;


--===================================================================================
PACKAGE gen_vectorial_pkg IS
--===================================================================================


-------------------------------------------------------------------------------------
--                                CONSTANTS
-------------------------------------------------------------------------------------

 
-------------------------------------------------------------------------------------
--                                  TYPES
-------------------------------------------------------------------------------------
    
    -- limit for synthesizable ranges
    SUBTYPE nat_synth_65536 IS NATURAL RANGE 0 TO 65535;
    SUBTYPE nat_synth_2048  IS NATURAL RANGE 0 TO 2047;
    SUBTYPE nat_synth_1024  IS NATURAL RANGE 0 TO 1023;      
    SUBTYPE nat_synth_512   IS NATURAL RANGE 0 TO 511;
    SUBTYPE nat_synth_256   IS NATURAL RANGE 0 TO 255;
    SUBTYPE nat_synth_128   IS NATURAL RANGE 0 TO 127;
    SUBTYPE nat_synth_64    IS NATURAL RANGE 0 TO 63;    
    SUBTYPE nat_synth_32    IS NATURAL RANGE 0 TO 31;  
    SUBTYPE nat_synth_16    IS NATURAL RANGE 0 TO 15;  
    
    SUBTYPE valores_vector  IS INTEGER RANGE -1 TO nat_synth_65536'high;        
    TYPE    vector_integer  IS ARRAY (nat_synth_128'high DOWNTO 0) OF valores_vector;              

            
-------------------------------------------------------------------------------------
--                                COMPONENTS
-------------------------------------------------------------------------------------
    
    COMPONENT gen_vectorial
        GENERIC (
            WIDTH           : NATURAL;                                  -- ancho de bus
            DEFAULT_VALUE   : STD_LOGIC                                 -- e.g. '0', '1', 'Z', ...
            );
        PORT (  
            clock           : IN STD_LOGIC;
            enable          : IN STD_LOGIC;
            areset          : IN STD_LOGIC;
            trigger         : IN STD_LOGIC;                             -- disparo de la generacion del vector 
            valores         : IN vector_integer;                        -- entrada de valores para generar el vector
            vector_out      : OUT STD_LOGIC_VECTOR(WIDTH-1 DOWNTO 0);   -- vector generado
            fin             : OUT STD_LOGIC;                            -- fin de la generacion
            error           : OUT STD_LOGIC                             -- error de configuracion o formato de valores incorrecto
            );                                                          
    END COMPONENT;
    
-------------------------------------------------------------------------------------
--                                FUNCTIONS
-------------------------------------------------------------------------------------

    -- devuelve el minimo numero de bits que necesita un entero en representacion binaria
    -- Esta funcion es usada por la funcion "bus_width"
    FUNCTION integer_bits (DATO_ENTRADA : IN valores_vector) RETURN NATURAL;
    
    -- calcula el ancho de bus min necesario para la generacion del vector de test segun 
    -- el tamaño de los valores a generar
    FUNCTION bus_width (valores: vector_integer) RETURN NATURAL;

    -- comprueba si los datos para generar el vector de test tienen un formato logico
    -- de acuerdo con lo descrito en la cabecera 
    FUNCTION check_format (valores: vector_integer; WIDTH: NATURAL) RETURN BOOLEAN;

  

END gen_vectorial_pkg; 


--===================================================================================
PACKAGE BODY gen_vectorial_pkg IS
--===================================================================================


-------------------------------------------------------------------------------------
--                                FUNCTIONS
-------------------------------------------------------------------------------------

    FUNCTION integer_bits(DATO_ENTRADA : IN valores_vector) RETURN NATURAL IS
        VARIABLE RESULTADO : nat_synth_16;  -- (0..15)
    BEGIN

        RESULTADO := 0;     -- default value

        FOR I IN 1 TO 15 LOOP               
            IF DATO_ENTRADA >= 2**I THEN
                RESULTADO := I;
            END IF;
        END LOOP;

        RETURN RESULTADO+1;             -- (max = 2**16 = 65536 <- T'valores_vector)

    END integer_bits;


-------------------------------------------------------------------------------------
    FUNCTION bus_width (valores: vector_integer) RETURN NATURAL IS
        VARIABLE min_bits : nat_synth_16;  -- (0..15) 
    BEGIN
        min_bits:=0;
        
        FOR i IN valores'length-1 DOWNTO 1 LOOP
            IF ((i MOD 2) /= 0) THEN
                IF (integer_bits(valores(i)) > min_bits+1) AND (valores(i) > 0) THEN
                    min_bits:= integer_bits(valores(i))-1;  -- (restar 1 evita que desborde)
                END IF;         
            END IF;
        END LOOP;
        
        RETURN min_bits+1; 
    END FUNCTION;
    
-------------------------------------------------------------------------------------
    FUNCTION check_format (valores: vector_integer; WIDTH: NATURAL) RETURN BOOLEAN IS

    BEGIN
        -- bus width parameter (in bus format) is not enough or overflows
        IF ((bus_width(valores) > WIDTH) AND (WIDTH > 1)) OR 
            (WIDTH > 16) OR
            (WIDTH = 0)  THEN
            RETURN FALSE;       
            
        -- input vector without end value (null)
        ELSIF (valores(valores'low) /= 0) THEN
            RETURN FALSE;
            
        -- negative number of cycles for any value
        ELSE                        
            FOR i IN valores'length-1 DOWNTO 1 LOOP 
                IF ((i MOD 2) /= 0) THEN
                    IF  (valores(i-1) <0) THEN                         
                        RETURN FALSE;                     
                    END IF;          
                END IF;     
            END LOOP;           
        END IF;     
        
        -- no error by default
        RETURN TRUE;                                
    END FUNCTION;


END gen_vectorial_pkg; 






LIBRARY ieee; 
USE ieee.std_logic_1164.all; 
USE ieee.std_logic_arith.all;
USE ieee.std_logic_signed.all;

LIBRARY work;
USE work.gen_vectorial_pkg.all;


--===================================================================================
ENTITY gen_vectorial IS
--===================================================================================

    GENERIC (
            WIDTH           : NATURAL;                                  -- ancho de bus
            DEFAULT_VALUE   : STD_LOGIC                                 -- e.g. '0', '1', 'Z', ...
            );
    PORT (  
            clock           : IN STD_LOGIC;
            enable          : IN STD_LOGIC;
            areset          : IN STD_LOGIC;
            trigger         : IN STD_LOGIC;                             -- disparo de la generacion del vector
            valores         : IN vector_integer;                        -- entrada de valores para generar el vector
            vector_out      : OUT STD_LOGIC_VECTOR(WIDTH-1 DOWNTO 0);   -- vector de test generado
            fin             : OUT STD_LOGIC;                            -- fin de la generacion
            error           : OUT STD_LOGIC                             -- error de configuracion o formato de valores incorrecto
        );                                                              
END gen_vectorial;

-------------------------------------------------------------------------------------

ARCHITECTURE gen_vectorial_arch OF gen_vectorial IS

    SIGNAL valores_reg  : vector_integer;   -- entrada registrada entre triggers

    SIGNAL num_cycles   : nat_synth_65536;  -- cuenta de ciclos de reloj del bit(serie)/valor(bus) actual
    SIGNAL indice       : nat_synth_128;    -- indice del valor en curso
    SIGNAL fin_cuenta   : STD_LOGIC;        -- para desabilitar proceso principal desde fin de cuenta hasta siguiente trigger
    
    SIGNAL error_aux    : STD_LOGIC;        -- para permitir lecturas de output port ("error")
    
    SIGNAL current_bit  : nat_synth_16;     -- bit en curso del valor actual
        
    SIGNAL first_trigger: BOOLEAN;          -- inhibe la generacion hasta que se produzca el primer trigger
                                            -- (antes del primer trigger aun no esta el valor por defecto 
                                            -- a la salida por lo que es un caso especial)
        
BEGIN

    -- Proceso de generacion del vector (se recorre el vector "valores" de BMS a LMS):
    
    --                127     126       125     124                          1        0
    --             -----------------------------------------------------------------------
    --            |  value | cycles |  value | cycles |   ...  |   ...  |    ?   |    0   | 
    --             -----------------------------------------------------------------------
    --              indice  indice-1  indice' indice'-1           
    
    --==========================================================================
    genera_vector:
    --==========================================================================
    PROCESS (clock, areset)
    
        -- para en formato serie pasar de integer a std_logic_vector
        VARIABLE auxiliar : STD_LOGIC_VECTOR(nat_synth_16'high DOWNTO 0); 
              
    BEGIN
    
        IF (areset='1') THEN
            fin         <= '0';
            fin_cuenta  <= '0';
            indice      <=  valores_reg'length-1;
            num_cycles  <=  0;
            vector_out  <= (OTHERS => DEFAULT_VALUE);
            
            first_trigger <= FALSE;                        
                        
        ELSIF RISING_EDGE(clock) THEN
            
            
            IF enable='1' THEN   
            
                ----------------------------------------------------------------
                -- valor de salida por defecto
                ----------------------------------------------------------------                        
                vector_out <= (OTHERS => DEFAULT_VALUE);                
                    
            
                IF error_aux='0' THEN   -- (si no hay error en el formato del vector)
                
                    ---------------------------------------------------------------
                    -- pulso de fin (por fin_cuenta)
                    ---------------------------------------------------------------
                                    
                    -- Si el tiempo entre triggers es insuficiente para la generacion, se asigna al 
                    -- vector su valor por defecto (no se asigna otro valor q no sea el de por defecto)
                    
                    -- [No se usan los valores de entrada registrados con el trigger, porque
                    -- aun no se han registrado (hasta el prox ciclo). Asi se consigue evitar otro
                    -- ciclo de retraso de la salida desde el trigger]
                    
                    IF (trigger='1') THEN                   
                                                                
                        fin           <= '0';             
                        indice        <=  valores'length-1;
                        num_cycles    <=  0;  
                        fin_cuenta    <= '0';                      
                         
                        first_trigger <= TRUE; 
                         
                        -- para formato serie: asignacion del primer bit del primer valor      
                        IF (WIDTH =1) THEN
                            IF (valores(valores'length-1) >=0) THEN
                                current_bit <= integer_bits(valores(valores'length-1)) -1; 
                            ELSE
                                current_bit <= 0;  -- ('Z')
                            END IF;
                        END IF;                           
                                            
                    -- Si se ha activado fin_cuenta, debe desactivarse "fin" para provocar un pulso de 1 ciclo,
                    -- y esperar a siguiente trigger ("fin_cuenta" permanece activo y entra siempre en este caso)
                    
                    ELSIF (fin_cuenta='1') THEN         -- fin de generacion de todos los valores
                        fin <= '0';                     -- cierra pulso de fin
                     
                           
                    ----------------------------------------------------------------                        
                    -- generacion del vector si estamos en tiempo entre triggers
                    ----------------------------------------------------------------
                    ELSIF first_trigger = TRUE THEN   
                                                            
                        -- ULTIMO VALOR (nulo) 
                        IF valores_reg(indice-1) = 0 THEN                   -- numero nulo de ciclos (fin de vector)          
                            fin_cuenta  <= '1';                             -- desabilita el proceso hasta proximo trigger
                            fin         <= '1';                             -- abre el pulso de fin                        
                                                                                                   
                        -- SIGUIENTE VALOR, ciclos del valor actual:
                        ELSE
                                
                            -- <><><><><><><><><>  formato bus <><><><><><><><><>
                            -- <><><><><><><><><><><><><><><><><><><><><><><><><>
                            IF WIDTH > 1 THEN
                            
                                -- output del valor actual
                                IF valores_reg(indice) < 0 THEN                 -- valor negativo ('Z')
                                    vector_out  <= (OTHERS=>'Z');
                                ELSE                                            -- valor en curso
                                    vector_out  <= CONV_STD_LOGIC_VECTOR(valores_reg(indice),WIDTH);                                
                                END IF;
                                
                                -- ¿paso a siguiente valor?
                                IF (num_cycles+1 >= valores_reg(indice-1)) THEN -- siguiente valor
                                    indice      <= indice -2;                       
                                    num_cycles  <= 0;   
                                ELSE                                            -- continua con el valor en curso
                                    num_cycles  <= num_cycles +1;       
                                END IF;
                               
                            -- <><><><><><><><><>  formato serie <><><><><><><><>
                            -- <><><><><><><><><><><><><><><><><><><><><><><><><>
                            ELSE    
                            
                                -- output del valor actual
                                IF valores_reg(indice) < 0 THEN                 -- valor negativo ('Z')
                                    vector_out  <= (OTHERS=>'Z');
                                ELSE                                            -- bit correspondiente del valor en curso
                                    auxiliar    := CONV_STD_LOGIC_VECTOR(valores_reg(indice), auxiliar'length);
                                    vector_out  <= (OTHERS => auxiliar(current_bit));
                                END IF;                                         
                                
                                -- ¿paso a siguiente bit/valor?
                                IF (num_cycles+1 >= valores_reg(indice-1)) THEN
                                
                                    IF (current_bit = 0) THEN                   -- siguiente valor
                                        indice      <= indice -2;                               
                                        num_cycles  <= 0;   
                                        
                                        IF (valores_reg(indice-2) >=0) THEN     -- primer bit del siguiente valor
                                            current_bit <= integer_bits(valores_reg(indice-2)) -1; 
                                        END IF;                                     
                                        -- (con valores negativos permanece "current_bit" =0)
                                
                                    ELSE                                        -- siguiente bit del valor en curso
                                        current_bit <= current_bit -1;  
                                        num_cycles  <= 0;            
                                    END IF;                                                             
                                ELSE                                            -- continua con el bit actual del valor en curso
                                    num_cycles  <= num_cycles +1;           
                                END IF;
                                                 
                            END IF;  -- formato bus/serie  
                                                                                                     
                        END IF;  -- ultimo/siguiente valor
                    
                    END IF;  -- fin_cuenta                     
                END IF;  -- error_aux      
            END IF;  -- enable
        END IF;  -- areset/rising_edge
    END PROCESS;
    
   

    -- Proceso de chequeo de formato del vector de entrada.
    --  "error"='1' si el formato es erroneo => desabilita el proceso de 
    --  generacion del vector (process "genera_vector")
    --==========================================================================
    chequea_formato:
    --==========================================================================
    PROCESS (clock, areset)
                  
    BEGIN
        IF (areset='1') THEN
            error_aux <= '0';
           
        ELSIF RISING_EDGE(clock) THEN
            IF enable='1' THEN
                IF trigger='1' THEN
                    IF check_format(valores, WIDTH) = FALSE THEN
                        error_aux   <='1';
                    ELSE
                        error_aux   <='0';
                        valores_reg <= valores;
                    END IF;
                END IF;
            END IF;          
        END IF;
    
    END PROCESS;
    
    error <= error_aux;



END gen_vectorial_arch;